{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sherlock Distributed Lock","text":"<p>Sherlock is a distributed locking library for JVM projects. It exposes both synchronous and reactive APIs (Reactor, RxJava, Kotlin Coroutines) and uses database connectors to store locks. It was created as a simple solution to manage distributed locks among microservices.</p>"},{"location":"#how-it-works","title":"How it works?","text":"<p>Locks are acquired for a specific duration. When lock owning instance unexpectedly goes down, lock is automatically released after expiration.</p>"},{"location":"#quick-start","title":"Quick start","text":"<ul> <li>MongoDB - using sherlock with MongoDB</li> <li>SQL - using sherlock with SQL databases</li> <li>In-Memory - using in-memory Sherlock for local development or testing</li> <li>Testing - stubbing and mocking Sherlock in unit tests</li> <li>Migrator - using Sherlock as for database migration</li> </ul>"},{"location":"about/","title":"About","text":"<ul> <li>GitHub Repository</li> <li>License</li> <li>Changelog</li> </ul>"},{"location":"locks/","title":"Locks","text":"<p>There are two main questions regarding lock acquisition:</p> <ul> <li>How long the lock should stay acquired? Lock Duration</li> <li>How to handle lock acquisition from the same instance? Lock Types</li> </ul>"},{"location":"locks/#lock-duration","title":"Lock Duration","text":"<p>Sherlock locks are acquired for a specific duration. Thanks to this approach when lock owning instance unexpectedly goes down, lock is automatically released after expiration.</p> <p>There are 3 methods to acquire a lock:</p> <ul> <li><code>lock.acquire()</code> - acquires lock for a default duration (5 minutes) after which lock is automatically released</li> <li><code>lock.acquire(Duration.ofMinutes(3))</code> - acquires a lock for a specific duration</li> <li><code>lock.acquireForever()</code> - acquires a lock forever. This lock never expires. Use it wisely.</li> </ul>"},{"location":"locks/#lock-types","title":"Lock Types","text":"<p>Sherlock provides different lock types to handle different locking scenarios:</p> <ul> <li>SingleEntrantDistributedLock - (default lock type) lock can be acquired only once. Even lock owner cannot acquire the lock for the second time.</li> <li>ReentrantDistributedLock - lock can be acquired by only one instance. Lock owner can acquire the lock for the second time.</li> <li>OverridingDistributedLock - lock state can be overridden freely. It's for administrative purposes.</li> </ul>"},{"location":"locks/#singleentrantdistributedlock","title":"SingleEntrantDistributedLock","text":"<p>Owner of a <code>SingleEntrantDistributedLock</code> cannot acquire the same lock twice. It's the default lock type.</p> <p>Acquiring lock with <code>SingleEntrantDistributedLock</code>:</p> <pre><code>DistributedLock lock = sherlock.createLock(lockId);\n\n// Instance A                  | // Instance B\nassert lock.acquire() == true  |\n                               | assert lock.lock() == false\nassert lock.acquire() == false |\n</code></pre> <p>Releasing <code>SingleEntrantDistributedLock</code> (the same as <code>ReentrantDistributedLock</code>): <pre><code>// Instance A                  | // Instance B\nassert lock.acquire() == true  |\n                               | assert lock.lock() == false\n                               | assert lock.release() == false\nassert lock.release() == true  |\nassert lock.release() == false |\n</code></pre></p>"},{"location":"locks/#reentrantdistributedlock","title":"ReentrantDistributedLock","text":"<p>Owner of a <code>ReentrantDistributedLock</code> can acquire the same lock multiple times</p> <p>Acquiring <code>ReentrantDistributedLock</code>: <pre><code>DistributedLock lock = sherlock.createReentrantLock(lockId);\n\n// Instance A                  | // Instance B\nassert lock.acquire() == true  |\n                               | assert lock.lock() == false\nassert lock.acquire() == true  |\n</code></pre></p> <p>Releasing <code>ReentrantDistributedLock</code> (the same as <code>SingleEntrantDistributedLock</code>): <pre><code>// Instance A                  | // Instance B\nassert lock.acquire() == true  |\n                               | assert lock.lock() == false\n                               | assert lock.release() == false\nassert lock.release() == true  |\nassert lock.release() == false |\n</code></pre></p>"},{"location":"locks/#overridingdistributedlock","title":"OverridingDistributedLock","text":"<p><code>OverridingDistributedLock</code> lock may be acquired and/or released any time. It was created for purely administrative tasks, like releasing a lock that was blocked in acquired state. </p> <p>Acquiring a <code>OverridingDistributedLock</code> <pre><code>DistributedLock lock = sherlock.createOverridingLock(lockId);\n\n// Instance A                  | // Instance B\nassert lock.acquire() == true  |\n                               | assert lock.lock() == true\nassert lock.acquire() == true  |\nassert lock.acquire() == true  |\n</code></pre></p> <p>Releasing a <code>OverridingDistributedLock</code> <pre><code>// Instance A                  | // Instance B\nassert lock.acquire() == true  |\n                               | assert lock.lock() == true\n                               | assert lock.release() == true\nassert lock.release() == false |\nassert lock.release() == false |\n</code></pre></p>"},{"location":"migrator/","title":"Migrator","text":"<p>Sherlock comes with a migration mechanism, implemented as a lightweight wrapper on distributed locks. Use this mechanism for a multi-step, one way migrations.</p> <p>Sherlock migrator enforces following migration rules:</p> <ul> <li>migrations must not be run in parallel</li> <li>migration steps are applied in order</li> <li>if migration step succeeds it must never be run again</li> <li>migration process stops when first step fails</li> </ul> <p>Learn more</p> <p>See full source code examples on  Github.</p>"},{"location":"migrator/#annotated-migration","title":"Annotated migration","text":"<p>Below example uses MongoDB, but sherlock migrator is available for all connectors.</p> SyncCoroutinesReactorRxJava <pre><code>import com.coditory.sherlock.Sherlock;\nimport com.coditory.sherlock.migrator.ChangeSet;\nimport com.coditory.sherlock.migrator.SherlockMigrator;\nimport com.coditory.sherlock.mongo.MongoSherlock;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MongoSyncAnnotatedMigrationSample {\n    private static MongoCollection&lt;Document&gt; locksCollection() {\n        String database = \"sherlock\";\n        MongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(locksCollection());\n        // first commit - all migrations are executed\n        SherlockMigrator.builder(sherlock)\n            .addAnnotatedChangeSets(new AnnotatedMigration())\n            .migrate();\n        // second commit - only new change-set is executed\n        SherlockMigrator.builder(sherlock)\n            .addAnnotatedChangeSets(new AnnotatedMigration2())\n            .migrate();\n    }\n\n    public static class AnnotatedMigration {\n        private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n        @ChangeSet(order = 0, id = \"change-set-a\")\n        public void changeSetA() {\n            logger.info(\"Annotated change-set: A\");\n        }\n\n        @ChangeSet(order = 1, id = \"change-set-b\")\n        public void changeSetB() {\n            logger.info(\"Annotated change-set: B\");\n        }\n    }\n\n    public static class AnnotatedMigration2 {\n        private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n        @ChangeSet(order = 0, id = \"change-set-a\")\n        public void changeSetA() {\n            logger.info(\"Annotated change-set: A\");\n        }\n\n        @ChangeSet(order = 1, id = \"change-set-b\")\n        public void changeSetB() {\n            logger.info(\"Annotated change-set: B\");\n        }\n\n        @ChangeSet(order = 2, id = \"change-set-c\")\n        public void changeSetC() {\n            logger.info(\"Annotated change-set: C\");\n        }\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.coroutines.migrator.SherlockMigrator\nimport com.coditory.sherlock.migrator.ChangeSet\nimport com.coditory.sherlock.mongo.coroutines.MongoSherlock\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport com.mongodb.kotlin.client.coroutine.MongoCollection\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.runBlocking\nimport org.bson.Document\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\nobject MongoKtAnnotatedMigrationSample {\n    private fun locksCollection(): MongoCollection&lt;Document&gt; {\n        val database = \"sherlock\"\n        val mongoClient = MongoClient.create(\"mongodb://localhost:27017/$database\")\n        return mongoClient\n            .getDatabase(database)\n            .getCollection(\"locks\")\n    }\n\n    private suspend fun sample() {\n        val sherlock = MongoSherlock.create(locksCollection())\n        // first commit - all migrations are executed\n        SherlockMigrator.builder(sherlock)\n            .addAnnotatedChangeSets(AnnotatedMigration())\n            .migrate()\n        // second commit - only new change-set is executed\n        SherlockMigrator.builder(sherlock)\n            .addAnnotatedChangeSets(AnnotatedMigration2())\n            .migrate()\n    }\n\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) {\n        runBlocking { sample() }\n    }\n\n    class AnnotatedMigration {\n        private val logger: Logger = LoggerFactory.getLogger(this.javaClass)\n\n        @ChangeSet(order = 0, id = \"change-set-a\")\n        suspend fun changeSetA() {\n            logger.info(\"Annotated change-set: A\")\n            delay(1)\n        }\n\n        @ChangeSet(order = 1, id = \"change-set-b\")\n        suspend fun changeSetB() {\n            logger.info(\"Annotated change-set: B\")\n            delay(1)\n        }\n    }\n\n    class AnnotatedMigration2 {\n        private val logger: Logger = LoggerFactory.getLogger(this.javaClass)\n\n        @ChangeSet(order = 0, id = \"change-set-a\")\n        fun changeSetA() {\n            logger.info(\"Annotated change-set: A\")\n        }\n\n        @ChangeSet(order = 1, id = \"change-set-b\")\n        fun changeSetB() {\n            logger.info(\"Annotated change-set: B\")\n        }\n\n        @ChangeSet(order = 2, id = \"change-set-c\")\n        fun changeSetC() {\n            logger.info(\"Annotated change-set: C\")\n        }\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.migrator.ChangeSet;\nimport com.coditory.sherlock.mongo.reactor.MongoSherlock;\nimport com.coditory.sherlock.reactor.Sherlock;\nimport com.coditory.sherlock.reactor.migrator.SherlockMigrator;\nimport com.mongodb.reactivestreams.client.MongoClient;\nimport com.mongodb.reactivestreams.client.MongoClients;\nimport com.mongodb.reactivestreams.client.MongoCollection;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport reactor.core.publisher.Mono;\n\npublic class MongoReactorAnnotatedMigrationSample {\n    private static MongoCollection&lt;Document&gt; locksCollection() {\n        String database = \"sherlock\";\n        MongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(locksCollection());\n        // first commit - all migrations are executed\n        SherlockMigrator.builder(sherlock)\n            .addAnnotatedChangeSets(new AnnotatedMigration())\n            .migrate()\n            .block();\n        // second commit - only new change-set is executed\n        SherlockMigrator.builder(sherlock)\n            .addAnnotatedChangeSets(new AnnotatedMigration2())\n            .migrate()\n            .block();\n    }\n\n    public static class AnnotatedMigration {\n        private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n        @ChangeSet(order = 0, id = \"change-set-a\")\n        public Mono&lt;?&gt; changeSetA() {\n            return Mono.fromRunnable(() -&gt; logger.info(\"Annotated change-set: A\"));\n        }\n\n        @ChangeSet(order = 1, id = \"change-set-b\")\n        public Mono&lt;?&gt; changeSetB() {\n            return Mono.fromRunnable(() -&gt; logger.info(\"Annotated change-set: B\"));\n        }\n    }\n\n    public static class AnnotatedMigration2 {\n        private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n        @ChangeSet(order = 0, id = \"change-set-a\")\n        public void changeSetA() {\n            logger.info(\"Annotated change-set: A\");\n        }\n\n        @ChangeSet(order = 1, id = \"change-set-b\")\n        public void changeSetB() {\n            logger.info(\"Annotated change-set: B\");\n        }\n\n        @ChangeSet(order = 2, id = \"change-set-c\")\n        public void changeSetC() {\n            logger.info(\"Annotated change-set: C\");\n        }\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.migrator.ChangeSet;\nimport com.coditory.sherlock.mongo.rxjava.MongoSherlock;\nimport com.coditory.sherlock.rxjava.Sherlock;\nimport com.coditory.sherlock.rxjava.migrator.SherlockMigrator;\nimport com.mongodb.reactivestreams.client.MongoClient;\nimport com.mongodb.reactivestreams.client.MongoClients;\nimport com.mongodb.reactivestreams.client.MongoCollection;\nimport io.reactivex.rxjava3.core.Completable;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MongoRxAnnotatedMigrationSample {\n    private static MongoCollection&lt;Document&gt; locksCollection() {\n        String database = \"sherlock\";\n        MongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(locksCollection());\n        // first commit - all migrations are executed\n        SherlockMigrator.builder(sherlock)\n            .addAnnotatedChangeSets(new AnnotatedMigration())\n            .migrate()\n            .blockingGet();\n        // second commit - only new change-set is executed\n        SherlockMigrator.builder(sherlock)\n            .addAnnotatedChangeSets(new AnnotatedMigration2())\n            .migrate()\n            .blockingGet();\n    }\n\n    public static class AnnotatedMigration {\n        private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n        @ChangeSet(order = 0, id = \"change-set-a\")\n        public Completable changeSetA() {\n            return Completable.fromRunnable(() -&gt; logger.info(\"Annotated change-set: A\"));\n        }\n\n        @ChangeSet(order = 1, id = \"change-set-b\")\n        public Completable changeSetB() {\n            return Completable.fromRunnable(() -&gt; logger.info(\"Annotated change-set: B\"));\n        }\n    }\n\n    public static class AnnotatedMigration2 {\n        private final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n        @ChangeSet(order = 0, id = \"change-set-a\")\n        public void changeSetA() {\n            logger.info(\"Annotated change-set: A\");\n        }\n\n        @ChangeSet(order = 1, id = \"change-set-b\")\n        public void changeSetB() {\n            logger.info(\"Annotated change-set: B\");\n        }\n\n        @ChangeSet(order = 2, id = \"change-set-c\")\n        public void changeSetC() {\n            logger.info(\"Annotated change-set: C\");\n        }\n    }\n}\n</code></pre>"},{"location":"migrator/#functional-migration","title":"Functional migration","text":"<p>Below example uses MongoDB, but sherlock migrator is available for all connectors.</p> SyncCoroutinesReactorRxJava <pre><code>import com.coditory.sherlock.Sherlock;\nimport com.coditory.sherlock.migrator.SherlockMigrator;\nimport com.coditory.sherlock.mongo.MongoSherlock;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MongoSyncMigrationSample {\n    private static final Logger logger = LoggerFactory.getLogger(MongoSyncMigrationSample.class);\n\n    private static MongoCollection&lt;Document&gt; locksCollection() {\n        String database = \"sherlock\";\n        MongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(locksCollection());\n        // first commit - all migrations are executed\n        SherlockMigrator.builder(sherlock)\n            .addChangeSet(\"change-set-1\", () -&gt; logger.info(\"Change-set 1\"))\n            .addChangeSet(\"change-set-2\", () -&gt; logger.info(\"Change-set 2\"))\n            .migrate();\n        // second commit - only new change-set is executed\n        SherlockMigrator.builder(sherlock)\n            .addChangeSet(\"change-set-1\", () -&gt; logger.info(\"Change-set 1\"))\n            .addChangeSet(\"change-set-2\", () -&gt; logger.info(\"Change-set 2\"))\n            .addChangeSet(\"change-set-3\", () -&gt; logger.info(\"Change-set 3\"))\n            .migrate();\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.coroutines.migrator.SherlockMigrator\nimport com.coditory.sherlock.mongo.coroutines.MongoSherlock\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport com.mongodb.kotlin.client.coroutine.MongoCollection\nimport kotlinx.coroutines.runBlocking\nimport org.bson.Document\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\nobject MongoKtMigrationSample {\n    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)\n\n    private fun locksCollection(): MongoCollection&lt;Document&gt; {\n        val database = \"sherlock\"\n        val mongoClient = MongoClient.create(\"mongodb://localhost:27017/$database\")\n        return mongoClient\n            .getDatabase(database)\n            .getCollection(\"locks\")\n    }\n\n    private suspend fun sample() {\n        val sherlock = MongoSherlock.create(locksCollection())\n        // first commit - all migrations are executed\n        SherlockMigrator.builder(sherlock)\n            .addChangeSet(\"change-set-1\") { logger.info(\"Change-set 1\") }\n            .addChangeSet(\"change-set-2\") { logger.info(\"Change-set 2\") }\n            .migrate()\n        // second commit - only new change-set is executed\n        SherlockMigrator.builder(sherlock)\n            .addChangeSet(\"change-set-1\") { logger.info(\"Change-set 1\") }\n            .addChangeSet(\"change-set-2\") { logger.info(\"Change-set 2\") }\n            .addChangeSet(\"change-set-3\") { logger.info(\"Change-set 3\") }\n            .migrate()\n    }\n\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) {\n        runBlocking { sample() }\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.mongo.reactor.MongoSherlock;\nimport com.coditory.sherlock.reactor.Sherlock;\nimport com.coditory.sherlock.reactor.migrator.SherlockMigrator;\nimport com.mongodb.reactivestreams.client.MongoClient;\nimport com.mongodb.reactivestreams.client.MongoClients;\nimport com.mongodb.reactivestreams.client.MongoCollection;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport reactor.core.publisher.Mono;\n\npublic class MongoReactorMigrationSample {\n    private static final Logger logger = LoggerFactory.getLogger(MongoReactorMigrationSample.class);\n\n    private static MongoCollection&lt;Document&gt; locksCollection() {\n        String database = \"sherlock\";\n        MongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(locksCollection());\n        // first commit - all migrations are executed\n        // acceptable changesets types: () -&gt; {}, Mono&lt;?&gt;, () -&gt; Mono&lt;?&gt;\n        SherlockMigrator.builder(sherlock)\n            .addChangeSet(\"change-set-1\", Mono.fromRunnable(() -&gt; logger.info(\"Change-set 1\")))\n            .addChangeSet(\"change-set-2\", () -&gt; Mono.fromRunnable(() -&gt; logger.info(\"Change-set 2\")))\n            .migrate()\n            .block();\n        // second commit - only new change-set is executed\n        SherlockMigrator.builder(sherlock)\n            .addChangeSet(\"change-set-1\", () -&gt; logger.info(\"Change-set 1\"))\n            .addChangeSet(\"change-set-2\", () -&gt; logger.info(\"Change-set 2\"))\n            .addChangeSet(\"change-set-3\", () -&gt; logger.info(\"Change-set 3\"))\n            .migrate()\n            .block();\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.mongo.rxjava.MongoSherlock;\nimport com.coditory.sherlock.rxjava.Sherlock;\nimport com.coditory.sherlock.rxjava.migrator.SherlockMigrator;\nimport com.mongodb.reactivestreams.client.MongoClient;\nimport com.mongodb.reactivestreams.client.MongoClients;\nimport com.mongodb.reactivestreams.client.MongoCollection;\nimport io.reactivex.rxjava3.core.Completable;\nimport io.reactivex.rxjava3.core.Single;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MongoRxMigrationSample {\n    private static final Logger logger = LoggerFactory.getLogger(MongoRxMigrationSample.class);\n\n    private static MongoCollection&lt;Document&gt; locksCollection() {\n        String database = \"sherlock\";\n        MongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(locksCollection());\n        Completable c = Completable.fromSingle(Single.just(\"asd\"));\n        // first commit - all migrations are executed\n        // acceptable changesets types: () -&gt; {}, Completable, () -&gt; Completable\n        SherlockMigrator.builder(sherlock)\n            .addChangeSet(\"change-set-1\", Completable.fromRunnable(() -&gt; logger.info(\"Change-set 1\")))\n            .addChangeSet(\"change-set-2\", () -&gt; Completable.fromRunnable(() -&gt; logger.info(\"Change-set 2\")))\n            .migrate()\n            .blockingGet();\n        // second commit - only new change-set is executed\n        SherlockMigrator.builder(sherlock)\n            .addChangeSet(\"change-set-1\", () -&gt; logger.info(\"Change-set 1\"))\n            .addChangeSet(\"change-set-2\", () -&gt; logger.info(\"Change-set 2\"))\n            .addChangeSet(\"change-set-3\", () -&gt; logger.info(\"Change-set 3\"))\n            .migrate()\n            .blockingGet();\n    }\n}\n</code></pre>"},{"location":"testing/","title":"Testing","text":"<p>Sherlock provides stubs and mocks for testing purposes. Try it out: <code>SherlockStub</code>, <code>ReactorSherlockStub</code>, <code>DistributedLockMock</code> and <code>ReactorDistributedLockMock</code>.</p> <p>Creating own stub and mocks</p> <p>Sherlock API consists mostly of interfaces, so it's easy to create stubs and mocks for your own purposes.</p> <p>Sample usage in spock tests:</p> <pre><code>def \"should release a lock after operation\"() {\n  given: \"there is a released lock\"\n    DistributedLockMock lock = DistributedLockMock.alwaysReleasedLock()\n  when: \"single instance action is executed\"\n    boolean taskPerformed = singleInstanceAction(lock)\n  then: \"the task was performed\"\n    taskPerformed == true\n  and: \"lock was acquired and released\"\n    lock.wasAcquiredAndReleased == true\n}\n\ndef \"should not perform single instance action when lock is locked\"() {\n  given: \"there is a lock acquired by other instance\"\n    DistributedLockMock lock = DistributedLockMock.alwaysAcquiredLock()\n  when: \"single instance action is executed\"\n    boolean taskPerformed = singleInstanceAction(lock)\n  then: \"action did not perform the task\"\n    taskPerformed == false\n  and: \"action failed acquiring the lock\"\n    lock.wasAcquireRejected == true\n  and: \"action did not release the lock\"\n    lock.wasReleaseInvoked == false\n}\n</code></pre> <p>In Memory Connector</p> <p>The easiest way to setup Sherlock in tests is to use In-Memory Connector. Use stubs when you need more control over the locking mechanism.</p>"},{"location":"connectors/","title":"Sherlock Connectors","text":"<p>Sherlock multiple database connectors to fit in your infrastructure. Provided connectors:</p> <ul> <li>Mongo Connector - Uses MongoDB and its JVM drivers to store locks</li> <li>SQL Connector - Uses SQL database (tested on Postgres and MySQL) and JDBC drivers to store locks</li> <li>In-Memory Connector - Stores locks in memory. Created for local development and testing.</li> </ul>"},{"location":"connectors/inmem/","title":"In Memory Distributed Lock","text":"<p>The in-memory connector was created for local development and testing purposes.</p>"},{"location":"connectors/inmem/#usage","title":"Usage","text":"<p>Add dependencies to <code>build.gradle.kts</code>:</p> SyncCoroutinesReactorRxJava <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-inmem:1.0.3\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-inmem-coroutine:1.0.3\")\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:$versions.coroutines\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-inmem-reactor:1.0.3\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-inmem-rxjava:1.0.3\")\n}\n</code></pre> <p>Create sherlock instance and distributed lock:</p> SyncCoroutinesReactorRxJava <pre><code>import com.coditory.sherlock.DistributedLock;\nimport com.coditory.sherlock.Sherlock;\nimport com.coditory.sherlock.inmem.InMemorySherlock;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class InMemSyncLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(InMemSyncLockSample.class);\n\n    public static void main(String[] args) {\n        Sherlock sherlock = InMemorySherlock.create();\n        DistributedLock lock = sherlock.createLock(\"sample-lock\");\n        lock.runLocked(() -&gt; logger.info(\"Lock acquired!\"));\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.inmem.coroutines.InMemorySherlock\nimport kotlinx.coroutines.runBlocking\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\nobject InMemKtLockSample {\n    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)\n\n    private suspend fun sample() {\n        val sherlock = InMemorySherlock.create()\n        val lock = sherlock.createLock(\"sample-lock\")\n        lock.runLocked {\n            logger.info(\"Lock acquired!\")\n        }\n    }\n\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) {\n        runBlocking { sample() }\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.inmem.reactor.InMemorySherlock;\nimport com.coditory.sherlock.reactor.DistributedLock;\nimport com.coditory.sherlock.reactor.Sherlock;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport reactor.core.publisher.Mono;\n\npublic class InMemReactorLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(InMemReactorLockSample.class);\n\n    public static void main(String[] args) {\n        Sherlock sherlock = InMemorySherlock.create();\n        DistributedLock lock = sherlock.createLock(\"sample-lock\");\n        lock.runLocked(Mono.fromCallable(() -&gt; {\n            logger.info(\"Lock acquired!\");\n            return true;\n        })).block();\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.inmem.rxjava.InMemorySherlock;\nimport com.coditory.sherlock.rxjava.DistributedLock;\nimport com.coditory.sherlock.rxjava.Sherlock;\nimport io.reactivex.rxjava3.core.Single;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class InMemRxLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(InMemRxLockSample.class);\n\n    public static void main(String[] args) {\n        Sherlock sherlock = InMemorySherlock.create();\n        DistributedLock lock = sherlock.createLock(\"sample-lock\");\n        lock.runLocked(Single.fromCallable(() -&gt; {\n            logger.info(\"Lock acquired!\");\n            return true;\n        })).blockingGet();\n    }\n}\n</code></pre> <p>Learn more</p> <p>See full source code example on  Github.</p>"},{"location":"connectors/inmem/#configuration","title":"Configuration","text":"<p>Configuration is available via sherlock builder:</p> SyncCoroutinesReactorRxJava <pre><code>MongoSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withSharedStorage()\n    .build();\n</code></pre> <pre><code>MongoSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withSharedStorage()\n    .build()\n</code></pre> <pre><code>MongoSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withSharedStorage()\n    .build();\n</code></pre> <pre><code>MongoSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withSharedStorage()\n    .build();\n</code></pre> <p>Parameters:</p> <ul> <li><code>clock</code> (default: <code>Clock.systemUTC()</code>) - used to generate acquisition and expiration timestamps.</li> <li><code>lockDuration</code> (default: <code>Duration.ofMinutes(5)</code>) - a default lock expiration time.   If lock is not released and expiration time passes, the lock is treated as released.</li> <li><code>ownerIdPolicy</code> (default: <code>uniqueOwnerId()</code>) - used to generate lock owner id.    It's executed once for every lock, during lock creation.   There are different policies available for generating lock ownerIds.</li> <li><code>sharedStorage</code> (default: no shared storage) - use shared storage for all in-mem locks.</li> </ul>"},{"location":"connectors/mongo/","title":"Mongo Distributed Lock","text":"<p>MongoDB connector enables distributed locking on MongoDB. It was tested on MongoDB v8.0.</p> <p>Mongo Client</p> <p>There is no need for a special MongoClient configuration. Default settings, where all writes use master node, are sufficient. Sherlock uses no read queries and only the following modification operations: <code>findOneAndReplace</code>, <code>findOneAndDelete</code>, <code>deleteMany</code>.</p>"},{"location":"connectors/mongo/#usage","title":"Usage","text":"<p>Add dependencies to <code>build.gradle.kts</code>:</p> SyncCoroutinesReactorRxJava <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-mongo:1.0.3\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-mongo-coroutines:1.0.3\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-mongo-reactor:1.0.3\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-mongo-rxjava:1.0.3\")\n}\n</code></pre> <p>Create sherlock instance and distributed lock:</p> SyncCoroutinesReactorRxJava <pre><code>import com.coditory.sherlock.DistributedLock;\nimport com.coditory.sherlock.Sherlock;\nimport com.coditory.sherlock.mongo.MongoSherlock;\nimport com.mongodb.client.MongoClient;\nimport com.mongodb.client.MongoClients;\nimport com.mongodb.client.MongoCollection;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MongoSyncLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(MongoSyncLockSample.class);\n\n    private static MongoCollection&lt;Document&gt; getCollection() {\n        String database = \"sherlock\";\n        String connectionString = \"mongodb://localhost:27017/\" + database;\n        MongoClient mongoClient = MongoClients.create(connectionString);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(getCollection());\n        DistributedLock lock = sherlock.createLock(\"sample-lock\");\n        lock.runLocked(() -&gt; logger.info(\"Lock acquired!\"));\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.mongo.coroutines.MongoSherlock\nimport com.mongodb.kotlin.client.coroutine.MongoClient\nimport com.mongodb.kotlin.client.coroutine.MongoCollection\nimport kotlinx.coroutines.runBlocking\nimport org.bson.Document\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\nobject MongoKtLockSample {\n    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)\n\n    private fun getCollection(): MongoCollection&lt;Document&gt; {\n        val database = \"sherlock\"\n        val mongoClient = MongoClient.create(\"mongodb://localhost:27017/$database\")\n        return mongoClient\n            .getDatabase(database)\n            .getCollection&lt;Document&gt;(\"locks\")\n    }\n\n    private suspend fun sample() {\n        val sherlock = MongoSherlock.create(getCollection())\n        val lock = sherlock.createLock(\"sample-lock\")\n        lock.runLocked { logger.info(\"Lock acquired!\") }\n    }\n\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) {\n        runBlocking { sample() }\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.mongo.reactor.MongoSherlock;\nimport com.coditory.sherlock.reactor.DistributedLock;\nimport com.coditory.sherlock.reactor.Sherlock;\nimport com.mongodb.reactivestreams.client.MongoClient;\nimport com.mongodb.reactivestreams.client.MongoClients;\nimport com.mongodb.reactivestreams.client.MongoCollection;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MongoReactorLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(MongoReactorLockSample.class);\n\n    private static MongoCollection&lt;Document&gt; getCollection() {\n        String database = \"sherlock\";\n        MongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(getCollection());\n        DistributedLock lock = sherlock.createLock(\"sample-lock2\");\n        lock.runLocked(() -&gt; logger.info(\"Lock acquired!\"))\n            .block();\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.mongo.rxjava.MongoSherlock;\nimport com.coditory.sherlock.rxjava.DistributedLock;\nimport com.coditory.sherlock.rxjava.Sherlock;\nimport com.mongodb.reactivestreams.client.MongoClient;\nimport com.mongodb.reactivestreams.client.MongoClients;\nimport com.mongodb.reactivestreams.client.MongoCollection;\nimport org.bson.Document;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MongoRxLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(MongoRxLockSample.class);\n\n    private static MongoCollection&lt;Document&gt; getCollection() {\n        String database = \"sherlock\";\n        MongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\n        return mongoClient\n            .getDatabase(\"sherlock\")\n            .getCollection(\"locks\");\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = MongoSherlock.create(getCollection());\n        DistributedLock lock = sherlock.createLock(\"sample-lock\");\n        lock.runLocked(() -&gt; logger.info(\"Lock acquired!\"))\n            .blockingGet();\n    }\n}\n</code></pre> <p>Learn more</p> <p>See full source code example on  Github.</p>"},{"location":"connectors/mongo/#configuration","title":"Configuration","text":"<p>Configuration is available via sherlock builder:</p> SyncCoroutinesReactorRxJava <pre><code>MongoSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withUniqueOwnerId()\n    .withLocksCollection(getCollection())\n    .build();\n</code></pre> <pre><code>MongoSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withUniqueOwnerId()\n    .withLocksCollection(getCollection())\n    .build()\n</code></pre> <pre><code>MongoSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withUniqueOwnerId()\n    .withLocksCollection(getCollection())\n    .build();\n</code></pre> <pre><code>MongoSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withLocksCollection(getCollection())\n    .build();\n</code></pre> <p>Parameters:</p> <ul> <li><code>clock</code> (default: <code>Clock.systemUTC()</code>) - used to generate acquisition and expiration timestamps.</li> <li><code>lockDuration</code> (default: <code>Duration.ofMinutes(5)</code>) - a default lock expiration time.   If lock is not released and expiration time passes, the lock is treated as released.</li> <li><code>ownerIdPolicy</code> (default: <code>uniqueOwnerId()</code>) - used to generate lock owner id.   It's executed once for every lock, during lock creation.   There are different policies available for generating lock ownerIds.</li> <li><code>locksCollection</code> - MongoDb collection used to store the locks.</li> </ul>"},{"location":"connectors/mongo/#locks-collection","title":"Locks collection","text":"<p>Sample lock document:</p> <pre><code>{\n  // Lock id\n  \"_id\": \"lock-id\",\n  // Owner id\n  \"acquiredBy\": \"aec5229a-1728-4200-b8d1-14f54ed9ac78\",\n  // Lock acquisition moment\n  \"acquiredAt\": {\n    \"$date\": \"2024-03-20T08:03:02.231Z\"\n  },\n  // Lock expiation time.\n  // Might be null for locks that do not expire\n  \"expiresAt\": {\n    \"$date\": \"2024-03-20T08:08:02.231Z\"\n  }\n}\n</code></pre>"},{"location":"connectors/sql/","title":"SQL Distributed Lock","text":"<p>SQL connector enables distributed locking on a relational databases. It was tested on PostgreSQL v17 and MySQL v9.</p> <p>Read and write from the same DB node</p> <p>Make sure that DB connection passed to Sherlock reads and writes to the same DB node so every lock change is visible to all of your services.</p>"},{"location":"connectors/sql/#usage","title":"Usage","text":"<p>Add dependencies to <code>build.gradle.kts</code>:</p> SyncCoroutinesReactorRxJava <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-sql:1.0.3\")\n    implementation(\"com.zaxxer:HikariCP:$versions.hikaricp\")\n    implementation(\"org.postgresql:postgresql:$versions.postgresql\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-sql-coroutines:1.0.3\")\n    implementation(\"org.postgresql:postgresql:$versions.postgres\")\n    implementation(\"com.zaxxer:HikariCP:$versions.hikaricp\")\n    implementation(\"org.postgresql:r2dbc-postgresql:$versions.r2dbc\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-sql-reactor:1.0.3\")\n    implementation(\"org.postgresql:postgresql:$versions.postgres\")\n    implementation(\"com.zaxxer:HikariCP:$versions.hikaricp\")\n    implementation(\"org.postgresql:r2dbc-postgresql:$versions.r2dbc\")\n}\n</code></pre> <pre><code>dependencies {\n    implementation(\"com.coditory.sherlock:sherlock-sql-rxjava:1.0.3\")\n    implementation(\"org.postgresql:postgresql:$versions.postgres\")\n    implementation(\"com.zaxxer:HikariCP:$versions.hikaricp\")\n    implementation(\"org.postgresql:r2dbc-postgresql:$versions.r2dbc\")\n}\n</code></pre> <p>Create sherlock instance and distributed lock:</p> SyncCoroutinesReactorRxJava <pre><code>import com.coditory.sherlock.DistributedLock;\nimport com.coditory.sherlock.Sherlock;\nimport com.coditory.sherlock.sql.SqlSherlock;\nimport com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.sql.DataSource;\n\npublic class PostgresSyncLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(PostgresSyncLockSample.class);\n\n    private static DataSource dataSource() {\n        HikariConfig config = new HikariConfig();\n        config.setJdbcUrl(\"jdbc:postgresql://localhost:5432/test\");\n        config.setUsername(\"postgres\");\n        config.setPassword(\"postgres\");\n        return new HikariDataSource(config);\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = SqlSherlock.create(dataSource());\n        DistributedLock lock = sherlock.createLock(\"sample-lock\");\n        lock.runLocked(() -&gt; logger.info(\"Lock acquired!\"));\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.sql.BindingMapper.POSTGRES_MAPPER\nimport com.coditory.sherlock.sql.coroutines.SqlSherlock\nimport io.r2dbc.spi.ConnectionFactories\nimport io.r2dbc.spi.ConnectionFactory\nimport io.r2dbc.spi.ConnectionFactoryOptions\nimport kotlinx.coroutines.runBlocking\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\nobject PostgresKtLockSample {\n    private val logger: Logger = LoggerFactory.getLogger(this.javaClass)\n\n    private fun getConnectionFactory(): ConnectionFactory {\n        val database = \"test\"\n        val options =\n            ConnectionFactoryOptions\n                .parse(\"r2dbc:postgresql://localhost:5432/$database\")\n                .mutate()\n                .option(ConnectionFactoryOptions.USER, \"postgres\")\n                .option(ConnectionFactoryOptions.PASSWORD, \"postgres\")\n                .option(ConnectionFactoryOptions.DATABASE, database)\n                .build()\n        return ConnectionFactories.get(options)\n    }\n\n    private suspend fun sample() {\n        val sherlock = SqlSherlock.create(getConnectionFactory(), POSTGRES_MAPPER)\n        val lock = sherlock.createLock(\"sample-lock\")\n        lock\n            .runLocked { logger.info(\"Lock acquired!\") }\n    }\n\n    @JvmStatic\n    fun main(args: Array&lt;String&gt;) {\n        runBlocking { sample() }\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.reactor.DistributedLock;\nimport com.coditory.sherlock.reactor.Sherlock;\nimport com.coditory.sherlock.sql.reactor.SqlSherlock;\nimport io.r2dbc.spi.ConnectionFactories;\nimport io.r2dbc.spi.ConnectionFactory;\nimport io.r2dbc.spi.ConnectionFactoryOptions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static com.coditory.sherlock.sql.BindingMapper.POSTGRES_MAPPER;\n\npublic class PostgresReactorLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(PostgresReactorLockSample.class);\n\n    private static ConnectionFactory getConnectionFactory() {\n        String database = \"test\";\n        ConnectionFactoryOptions options = ConnectionFactoryOptions\n            .parse(\"r2dbc:postgresql://localhost:5432/\" + database)\n            .mutate()\n            .option(ConnectionFactoryOptions.USER, \"postgres\")\n            .option(ConnectionFactoryOptions.PASSWORD, \"postgres\")\n            .option(ConnectionFactoryOptions.DATABASE, database)\n            .build();\n        return ConnectionFactories.get(options);\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = SqlSherlock.create(getConnectionFactory(), POSTGRES_MAPPER);\n        DistributedLock lock = sherlock.createLock(\"sample-lock\");\n        lock.runLocked(() -&gt; logger.info(\"Lock acquired!\"))\n            .block();\n    }\n}\n</code></pre> <pre><code>import com.coditory.sherlock.rxjava.DistributedLock;\nimport com.coditory.sherlock.rxjava.Sherlock;\nimport com.coditory.sherlock.sql.rxjava.SqlSherlock;\nimport io.r2dbc.spi.ConnectionFactories;\nimport io.r2dbc.spi.ConnectionFactory;\nimport io.r2dbc.spi.ConnectionFactoryOptions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static com.coditory.sherlock.sql.BindingMapper.POSTGRES_MAPPER;\n\npublic class PostgresRxLockSample {\n    private static final Logger logger = LoggerFactory.getLogger(PostgresRxLockSample.class);\n\n    private static ConnectionFactory getConnectionFactory() {\n        String database = \"test\";\n        ConnectionFactoryOptions options = ConnectionFactoryOptions\n            .parse(\"r2dbc:postgresql://localhost:5432/\" + database)\n            .mutate()\n            .option(ConnectionFactoryOptions.USER, \"postgres\")\n            .option(ConnectionFactoryOptions.PASSWORD, \"postgres\")\n            .option(ConnectionFactoryOptions.DATABASE, database)\n            .build();\n        return ConnectionFactories.get(options);\n    }\n\n    public static void main(String[] args) {\n        Sherlock sherlock = SqlSherlock.create(getConnectionFactory(), POSTGRES_MAPPER);\n        DistributedLock lock = sherlock.createLock(\"sample-lock\");\n        lock.runLocked(() -&gt; logger.info(\"Lock acquired!\"))\n            .blockingGet();\n    }\n}\n</code></pre> <p>These examples use Hikari Connection Pool, but any implementation of <code>java.sql.DataSource</code> will suffice.</p> <p>Learn more</p> <p>See full source code example on Github.</p>"},{"location":"connectors/sql/#configuration","title":"Configuration","text":"<p>Configuration is available via sherlock builder:</p> SyncCoroutinesReactorRxJava <pre><code>SqlSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withDataSource(dataSource())\n    .withLocksTable(\"LOCKS\")\n    .build();\n</code></pre> <pre><code>SqlSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withBindingMapper(BindingMapper.POSTGRES_MAPPER)\n    .withConnectionFactory(getConnectionFactory())\n    .withLocksTable(\"LOCKS\")\n    .build()\n</code></pre> <pre><code>SqlSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withBindingMapper(BindingMapper.POSTGRES_MAPPER)\n    .withConnectionFactory(getConnectionFactory())\n    .withLocksTable(\"LOCKS\")\n    .build();\n</code></pre> <pre><code>SqlSherlock.builder()\n    .withClock(Clock.systemUTC())\n    .withLockDuration(Duration.ofMinutes(5))\n    .withOwnerIdPolicy(OwnerIdPolicy.uniqueOwnerId())\n    .withBindingMapper(BindingMapper.POSTGRES_MAPPER)\n    .withConnectionFactory(getConnectionFactory())\n    .withLocksTable(\"LOCKS\")\n    .build();\n</code></pre> <p>Parameters:</p> <ul> <li><code>clock</code> (default: <code>Clock.systemUTC()</code>) - used to generate acquisition and expiration timestamps.</li> <li><code>lockDuration</code> (default: <code>Duration.ofMinutes(5)</code>) - a default lock expiration time.   If lock is not released and expiration time passes, the lock is treated as released.</li> <li><code>ownerIdPolicy</code> (default: <code>uniqueOwnerId()</code>) - used to generate lock owner id.   It's executed once for every lock, during lock creation.   There are different policies available for generating lock ownerIds.</li> <li><code>locksTable</code> (default: <code>\"LOCKS\"</code>) - locks database name</li> <li><code>connectionFactory</code> (only in: Reactor, RxJava, Coroutines) - database connection factory</li> <li><code>bindingMapper</code> (only in: Reactor, RxJava, Coroutines) - specifies DB type for proper SQL query mapping</li> <li><code>dataSource</code> (only in synchronous) - database data source</li> </ul>"},{"location":"connectors/sql/#locks-table","title":"Locks Table","text":"<p>Locks table is automatically created if it does not already exist. Table is created with a following SQL:</p> <pre><code>CREATE TABLE LOCKS (\n  -- Lock id\n  ID VARCHAR(100) NOT NULL,\n  -- Owner id\n  ACQUIRED_BY VARCHAR(100) NOT NULL,\n  -- Lock acquisition moment\n  ACQUIRED_AT TIMESTAMP(3) NOT NULL,\n  -- Lock expiration time\n  -- Might be null for locks that do not expire\n  EXPIRES_AT TIMESTAMP(3),\n  PRIMARY KEY (ID)\n)\nCREATE INDEX LOCKS_IDX ON LOCKS (ID, ACQUIRED_BY, EXPIRES_AT)\n</code></pre>"}]}